# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yBwnUF98Iq11COZGpl7kSHkaGbAYXYPh
"""

!pip install gradio

import torch
from torch import nn, optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
import gradio as gr
import numpy as np
from PIL import Image

# Loading MNIST data
transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])

train_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)
test_dataset = datasets.MNIST(root='./data', train=False, download=True, transform=transform)

train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=64, shuffle=False)

# Define neural network model
class MNISTClassifier(nn.Module):
    def __init__(self):
        super(MNISTClassifier, self).__init__()
        self.fc1 = nn.Linear(28 * 28, 128)
        self.fc2 = nn.Linear(128, 64)
        self.fc3 = nn.Linear(64, 10)

    def forward(self, x):
        x = x.view(-1, 28 * 28)
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        x = self.fc3(x)
        return x

# Instantiate the model
model = MNISTClassifier()

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training the model
for epoch in range(5):
    running_loss = 0.0
    for images, labels in train_loader:
        optimizer.zero_grad()

        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
    print(f"Epoch {epoch+1}, Loss: {running_loss/len(train_loader)}")

import matplotlib.pyplot as plt

# Get the weights of the first layer
weights = model.fc1.weight.data
fig, axes = plt.subplots(nrows=8, ncols=16, figsize=(16, 8))

for i, ax in enumerate(axes.flatten()):
    ax.imshow(weights[i].view(28, 28), cmap='gray')
    ax.axis('off')

plt.show()

# Save the trained model
torch.save(model.state_dict(), 'mnist_classifier.pth')

# Load the saved model
model.load_state_dict(torch.load('mnist_classifier.pth'))
model.eval()

# Function to predict digits
def predict_digit(image):
    # Preprocess the input image
    image = Image.fromarray((image * 255).astype('uint8')).convert('L')
    image = transform(image).unsqueeze(0)

    # Make prediction
    with torch.no_grad():
        output = model(image)
        _, predicted = torch.max(output.data, 1)

    return int(predicted)

# Interface for MNIST digit prediction
mnist_interface = gr.Interface(
    fn=predict_digit,
    inputs="sketchpad",
    outputs="text",
    title="MNIST Digit Classifier",
    description="Draw a digit and see the model's prediction."
)

# Launch the interface
mnist_interface.launch()